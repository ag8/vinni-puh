<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ВинниГесср</title>
    <link rel="icon" type="image/png" href="https://static.wikia.nocookie.net/winniepooh/images/2/29/%D0%92%D0%B8%D0%BD%D0%BD%D0%B8-%D0%9F%D1%83%D1%85.png/revision/latest?cb=20210129021723&path-prefix=ru">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c1810;
            color: #f5e6d3;
            min-height: 100vh;
            overflow: hidden;
        }

        /* Start Screen */
        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #3d2317 0%, #1a0d08 100%);
        }

        #start-screen h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #start-screen p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.8;
        }

        .start-btn {
            padding: 1rem 3rem;
            font-size: 1.5rem;
            background: #8b5a2b;
            color: #f5e6d3;
            border: 3px solid #d4a574;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-btn:hover {
            background: #a0522d;
            transform: scale(1.05);
        }

        /* Game Screen */
        #game-screen {
            display: none;
            height: 100vh;
            position: relative;
        }

        /* Level Video */
        #level-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background: #1a0d08;
        }

        /* Rewatch Button */
        #rewatch-btn {
            position: absolute;
            top: 80px;
            right: 20px;
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
            background: rgba(0,0,0,0.7);
            color: #f5e6d3;
            border: 2px solid #d4a574;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #rewatch-btn:hover {
            background: rgba(139, 90, 43, 0.8);
        }

        #rewatch-btn .play-icon {
            font-size: 1.2rem;
        }

        /* Header */
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 1rem 2rem;
            background: linear-gradient(180deg, rgba(0,0,0,0.7) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #level-indicator {
            font-size: 1.5rem;
            font-weight: bold;
        }

        #current-player {
            font-size: 1.3rem;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: bold;
        }

        /* Player Colors */
        .player-1 { background: #e74c3c; }
        .player-2 { background: #3498db; }
        .player-3 { background: #2ecc71; }
        .player-4 { background: #f39c12; }

        /* Webcam elements - keep it sneaky! */
        #webcam-container {
            position: fixed;
            bottom: 5px;
            left: 5px;
            width: 1px;
            height: 1px;
            opacity: 0.01;
            overflow: hidden;
            z-index: -1;
            display: none;
        }

        #webcam-video {
            width: 200px;
            height: 150px;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #webcam-canvas {
            display: none;
        }

        #photo-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.1s;
        }

        #photo-flash.flash {
            opacity: 1;
        }

        /* Player avatars in scoreboard */
        .player-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid white;
            margin-right: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }

        #score-row-0 .player-avatar { border-color: #e74c3c; }
        #score-row-1 .player-avatar { border-color: #3498db; }
        #score-row-2 .player-avatar { border-color: #2ecc71; }
        #score-row-3 .player-avatar { border-color: #f39c12; }

        .score-row {
            display: flex;
            align-items: center;
        }

        /* Map Container */
        #map-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 280px;
            height: 220px;
            border: 4px solid #d4a574;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            background: #1a0d08;
            transition: width 0.3s ease, height 0.3s ease;
        }

        #map-container:hover {
            width: 55vw;
            height: 70vh;
        }

        #map-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: none;
        }

        #map-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* Zoom controls */
        #map-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 20;
        }

        .map-control-btn {
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #d4a574;
            border-radius: 6px;
            color: #f5e6d3;
            font-size: 1.4rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .map-control-btn:hover {
            background: rgba(139, 90, 43, 0.8);
        }

        #zoom-level {
            font-size: 0.75rem;
            text-align: center;
            color: #d4a574;
            background: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Pins */
        .pin {
            position: absolute;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            border: 4px solid white;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 3px rgba(0,0,0,0.7), 0 4px 12px rgba(0,0,0,0.5);
            z-index: 10;
            overflow: hidden;
        }

        .pin img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .pin::after {
            content: attr(data-player);
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 4px black, 0 0 4px black, 1px 1px 2px black;
            background: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .pin.has-photo::after {
            display: none;
        }

        .pin-score {
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.85);
            color: #4ade80;
            font-size: 14px;
            font-weight: bold;
            padding: 3px 8px;
            border-radius: 6px;
            white-space: nowrap;
            pointer-events: none;
        }

        .pin.correct {
            background: gold !important;
            border-color: white;
            width: 36px;
            height: 36px;
            z-index: 15;
            box-shadow: 0 0 0 3px rgba(0,0,0,0.7), 0 0 15px rgba(255,215,0,0.8), 0 3px 8px rgba(0,0,0,0.5);
        }

        .pin.correct::after {
            content: '★';
            color: gold;
            font-size: 18px;
            background: rgba(0,0,0,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            top: -32px;
        }

        /* Distance lines SVG */
        #lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .distance-line-outline {
            stroke: rgba(0, 0, 0, 0.8);
            stroke-width: 8;
            stroke-dasharray: 12, 6;
            stroke-linecap: round;
            fill: none;
        }

        .distance-line {
            stroke-width: 4;
            stroke-dasharray: 12, 6;
            stroke-linecap: round;
            fill: none;
        }

        /* Confirm Button */
        #confirm-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 2.5rem 3rem;
            font-size: 1.5rem;
            font-weight: bold;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            display: none;
            z-index: 30;
            transition: all 0.2s;
        }

        #confirm-btn:hover {
            background: #2ecc71;
            transform: scale(1.05);
        }

        #confirm-btn.visible {
            display: block;
        }

        /* Grabbing cursor for panning */
        #map-container.panning {
            cursor: grabbing;
        }

        #map-container.can-pan {
            cursor: grab;
        }

        /* Scoreboard */
        #scoreboard {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 10px;
            min-width: 200px;
        }

        #scoreboard h3 {
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #d4a574;
            padding-bottom: 0.5rem;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            align-items: center;
        }

        .score-row .player-dot {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .score-row .player-name {
            flex: 1;
        }

        .score-row span:last-child {
            font-weight: bold;
            font-size: 1.1rem;
        }

        /* Results Screen */
        #results-screen {
            display: none;
            height: 100vh;
            background: #1a0d08;
            position: relative;
        }

        #final-map-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #final-map-wrapper {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #final-map-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #final-lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #final-scores-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 1.5rem;
            border-radius: 15px;
            border: 3px solid #d4a574;
            min-width: 280px;
        }

        #final-scores-panel h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            text-align: center;
            border-bottom: 2px solid #d4a574;
            padding-bottom: 0.5rem;
        }

        .final-score-row {
            display: flex;
            justify-content: space-between;
            padding: 0.8rem;
            margin: 0.4rem 0;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 1.1rem;
        }

        .final-score-row.winner {
            background: rgba(212, 165, 116, 0.3);
            border: 2px solid #d4a574;
        }

        .final-score-row .place {
            font-weight: bold;
            margin-right: 0.8rem;
        }

        #play-again-btn {
            margin-top: 1rem;
            width: 100%;
            padding: 0.8rem;
            font-size: 1.1rem;
            background: #8b5a2b;
            color: #f5e6d3;
            border: 3px solid #d4a574;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #play-again-btn:hover {
            background: #a0522d;
            transform: scale(1.05);
        }

        /* Level labels on final map */
        .level-label {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #d4a574;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Round Results (in sidebar) */
        #round-results {
            display: none;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #d4a574;
        }

        #round-results h4 {
            margin-bottom: 0.5rem;
            color: #d4a574;
        }

        .level-result-row {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            margin: 0.2rem 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            font-size: 0.85rem;
            align-items: center;
        }

        .level-result-row .player-name {
            flex: 1;
        }

        .level-result-row .player-avatar {
            width: 32px;
            height: 32px;
            border-width: 3px;
        }

        .level-result-row .distance {
            opacity: 0.7;
            margin-right: 0.5rem;
        }

        .level-result-row .points {
            font-weight: bold;
        }

        #next-level-btn {
            margin-top: 1rem;
            width: 100%;
            padding: 0.7rem;
            font-size: 1rem;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #next-level-btn:hover {
            background: #2ecc71;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 1rem;
            border-radius: 10px;
            max-width: 300px;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <!-- Webcam elements -->
    <div id="webcam-container">
        <video id="webcam-video" autoplay playsinline></video>
    </div>
    <canvas id="webcam-canvas" width="200" height="200"></canvas>
    <div id="photo-flash"></div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>ВинниГесср</h1>
        <p>Земля Винни-Пуха • 4 игрока</p>
        <button class="start-btn" onclick="startGame()">Начать игру</button>
    </div>

    <!-- Game Screen -->
    <div id="game-screen">
        <video id="level-video" autoplay playsinline></video>

        <div id="header">
            <div id="level-indicator">Уровень 1/3</div>
            <div id="current-player" class="player-1">Игрок 1</div>
        </div>

        <button id="rewatch-btn" onclick="rewatchVideo()">
            <span class="play-icon">▶</span> Пересмотреть
        </button>

        <div id="scoreboard">
            <h3>Счёт</h3>
            <div class="score-row" id="score-row-0">
                <span class="player-dot" style="background: #e74c3c;"></span>
                <span class="player-name">Игрок 1</span>
                <span id="score-1">0</span>
            </div>
            <div class="score-row" id="score-row-1">
                <span class="player-dot" style="background: #3498db;"></span>
                <span class="player-name">Игрок 2</span>
                <span id="score-2">0</span>
            </div>
            <div class="score-row" id="score-row-2">
                <span class="player-dot" style="background: #2ecc71;"></span>
                <span class="player-name">Игрок 3</span>
                <span id="score-3">0</span>
            </div>
            <div class="score-row" id="score-row-3">
                <span class="player-dot" style="background: #f39c12;"></span>
                <span class="player-name">Игрок 4</span>
                <span id="score-4">0</span>
            </div>

            <div id="round-results">
                <h4>Результаты раунда</h4>
                <div id="level-scores"></div>
                <button id="next-level-btn" onclick="nextLevel()">Следующий уровень</button>
            </div>
        </div>

        <div id="instructions">
            Нажмите на карту, чтобы поставить метку. Колёсико мыши = зум. Перетаскивание = перемещение.
        </div>

        <div id="map-container">
            <div id="map-wrapper">
                <img id="map-image" src="map.jpg" alt="Map">
                <svg id="lines-svg"></svg>
            </div>
            <div id="map-controls">
                <button class="map-control-btn" onclick="zoomIn()" title="Приблизить">+</button>
                <button class="map-control-btn" onclick="zoomOut()" title="Отдалить">−</button>
                <button class="map-control-btn" onclick="resetZoom()" title="Сбросить">⌂</button>
                <div id="zoom-level">100%</div>
            </div>
            <button id="confirm-btn" onclick="confirmPin()">Подтвердить</button>
        </div>
    </div>

    <!-- Results Screen -->
    <div id="results-screen">
        <div id="final-map-container">
            <div id="final-map-wrapper">
                <img id="final-map-image" src="map.jpg" alt="Final Map">
                <svg id="final-lines-svg"></svg>
            </div>
        </div>
        <div id="final-scores-panel">
            <h2>Финальные результаты</h2>
            <div id="final-scores"></div>
            <button id="play-again-btn" onclick="resetGame()">Играть снова</button>
        </div>
    </div>

    <script>
        // ===========================================
        // CONFIGURATION - Edit correct locations here
        // ===========================================
        // Coordinates are percentages (0-100) of the map image
        // To find coordinates: open browser console, click on map,
        // coordinates will be logged

        const LEVELS = [
            {
                video: 'assets/clip_1_48-1_49.mp4',
                correctX: 54.9,
                correctY: 59.7
            },
            {
                video: 'assets/clip_4_38-4_44.mp4',
                correctX: 63.5,
                correctY: 76.9
            },
            {
                video: 'assets/clip_9_33-9_39.mp4',
                correctX: 72.2,
                correctY: 54.5
            }
        ];

        const PLAYER_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12'];
        const PLAYER_NAMES = ['Игрок 1', 'Игрок 2', 'Игрок 3', 'Игрок 4'];
        const NUM_PLAYERS = 4;
        const MAX_SCORE = 5000;

        // Map diagonal size (sqrt of 100^2 + 100^2) for percentage-based coordinates
        const MAP_DIAGONAL = Math.sqrt(100 * 100 + 100 * 100); // ≈ 141.42

        // ===========================================
        // GAME STATE
        // ===========================================
        let currentLevel = 0;
        let currentPlayer = 0;
        let scores = [0, 0, 0, 0];
        let currentPins = []; // Pins for current level
        let tempPin = null;   // Temporary pin before confirmation
        let allGamePins = []; // Store all pins from all levels for final summary
        let playerPhotos = [null, null, null, null]; // Store player photos
        let webcamStream = null;

        // ===========================================
        // ZOOM & PAN STATE
        // ===========================================
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let startPanX = 0;
        let startPanY = 0;
        let lastMouseX = 0;
        let lastMouseY = 0;

        const MIN_ZOOM = 1;
        const MAX_ZOOM = 5;
        const ZOOM_STEP = 0.3;

        // ===========================================
        // WEBCAM FUNCTIONS
        // ===========================================

        async function initWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: 200, height: 200 }
                });
                const video = document.getElementById('webcam-video');
                video.srcObject = webcamStream;
                return true;
            } catch (err) {
                console.log('Webcam not available:', err);
                return false;
            }
        }

        function showWebcam(show) {
            document.getElementById('webcam-container').style.display = show ? 'block' : 'none';
        }

        function capturePhoto() {
            const video = document.getElementById('webcam-video');
            const canvas = document.getElementById('webcam-canvas');
            const ctx = canvas.getContext('2d');

            // Draw mirrored image
            ctx.save();
            ctx.scale(-1, 1);
            ctx.drawImage(video, -200, 0, 200, 200);
            ctx.restore();

            // Flash effect
            const flash = document.getElementById('photo-flash');
            flash.classList.add('flash');
            setTimeout(() => flash.classList.remove('flash'), 150);

            // Return data URL
            return canvas.toDataURL('image/jpeg', 0.8);
        }

        function updateScoreboardWithPhotos() {
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const row = document.getElementById(`score-row-${i}`);
                const dot = row.querySelector('.player-dot');

                if (playerPhotos[i]) {
                    // Replace dot with avatar
                    if (!row.querySelector('.player-avatar')) {
                        const avatar = document.createElement('img');
                        avatar.className = 'player-avatar';
                        avatar.src = playerPhotos[i];
                        dot.replaceWith(avatar);
                    }
                }
            }
        }

        // ===========================================
        // GAME FUNCTIONS
        // ===========================================

        async function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';

            // Initialize webcam for first round photos
            await initWebcam();
            showWebcam(true);

            loadLevel(0);
        }

        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            currentPlayer = 0;
            currentPins = [];
            tempPin = null;

            // Reset zoom/pan for new level
            resetZoom();

            // Show webcam only on first level
            showWebcam(levelIndex === 0 && webcamStream);

            // Update UI
            document.getElementById('level-indicator').textContent =
                `Уровень ${levelIndex + 1}/3`;

            // Load and play video
            const video = document.getElementById('level-video');
            video.src = LEVELS[levelIndex].video;
            video.play();

            updateCurrentPlayer();
            clearPins();
            document.getElementById('confirm-btn').classList.remove('visible');
            document.getElementById('round-results').style.display = 'none';
        }

        function rewatchVideo() {
            const video = document.getElementById('level-video');
            video.currentTime = 0;
            video.play();
        }

        function updateCurrentPlayer() {
            const playerDiv = document.getElementById('current-player');
            playerDiv.textContent = PLAYER_NAMES[currentPlayer];
            playerDiv.className = `player-${currentPlayer + 1}`;
        }

        // ===========================================
        // ZOOM & PAN FUNCTIONS
        // ===========================================

        function updateMapTransform() {
            const wrapper = document.getElementById('map-wrapper');
            wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            document.getElementById('zoom-level').textContent = `${Math.round(zoom * 100)}%`;

            // Update cursor based on zoom level
            const container = document.getElementById('map-container');
            if (zoom > 1) {
                container.classList.add('can-pan');
            } else {
                container.classList.remove('can-pan');
            }
        }

        function zoomIn() {
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();
            zoomAtPoint(rect.width / 2, rect.height / 2, ZOOM_STEP);
        }

        function zoomOut() {
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();
            zoomAtPoint(rect.width / 2, rect.height / 2, -ZOOM_STEP);
        }

        function zoomAtPoint(clientX, clientY, delta) {
            const oldZoom = zoom;
            zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom + delta));

            if (zoom !== oldZoom) {
                // Adjust pan to zoom toward the mouse position
                const zoomRatio = zoom / oldZoom;
                panX = clientX - (clientX - panX) * zoomRatio;
                panY = clientY - (clientY - panY) * zoomRatio;

                constrainPan();
                updateMapTransform();
            }
        }

        function resetZoom() {
            zoom = 1;
            panX = 0;
            panY = 0;
            updateMapTransform();
        }

        function constrainPan() {
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();

            const maxPanX = 0;
            const maxPanY = 0;
            const minPanX = rect.width * (1 - zoom);
            const minPanY = rect.height * (1 - zoom);

            panX = Math.max(minPanX, Math.min(maxPanX, panX));
            panY = Math.max(minPanY, Math.min(maxPanY, panY));
        }

        // ===========================================
        // PIN FUNCTIONS
        // ===========================================

        function placePin(clickX, clickY) {
            const mapWrapper = document.getElementById('map-wrapper');
            const container = document.getElementById('map-container');
            const rect = container.getBoundingClientRect();

            // Convert click position to percentage of the original (unzoomed) map
            const mapX = (clickX - panX) / zoom;
            const mapY = (clickY - panY) / zoom;

            const x = (mapX / rect.width) * 100;
            const y = (mapY / rect.height) * 100;

            // Validate bounds
            if (x < 0 || x > 100 || y < 0 || y > 100) return;

            // Log for debugging/setting up correct answers
            console.log(`Pin placed at: X=${x.toFixed(1)}%, Y=${y.toFixed(1)}%`);

            // Remove temp pin if exists
            if (tempPin) {
                tempPin.remove();
            }

            // Create new pin
            tempPin = createPinElement(x, y, currentPlayer, true);
            mapWrapper.appendChild(tempPin);

            // Show confirm button
            document.getElementById('confirm-btn').classList.add('visible');
        }

        function createPinElement(x, y, playerIndex, isTemp = false) {
            const pin = document.createElement('div');
            pin.className = 'pin';
            pin.style.left = `${x}%`;
            pin.style.top = `${y}%`;
            pin.style.background = PLAYER_COLORS[playerIndex];
            pin.style.borderColor = PLAYER_COLORS[playerIndex];
            pin.dataset.player = playerIndex + 1;
            pin.dataset.x = x;
            pin.dataset.y = y;
            if (isTemp) {
                pin.id = 'temp-pin';
            }

            // Add photo if available (for non-temp pins on levels after first)
            if (!isTemp && playerPhotos[playerIndex]) {
                const img = document.createElement('img');
                img.src = playerPhotos[playerIndex];
                pin.appendChild(img);
                pin.classList.add('has-photo');
            }

            return pin;
        }

        function confirmPin() {
            if (!tempPin) return;

            // Capture photo on first level
            if (currentLevel === 0 && webcamStream) {
                playerPhotos[currentPlayer] = capturePhoto();
                updateScoreboardWithPhotos();
            }

            // Add photo to pin if available
            if (playerPhotos[currentPlayer]) {
                const img = document.createElement('img');
                img.src = playerPhotos[currentPlayer];
                tempPin.appendChild(img);
                tempPin.classList.add('has-photo');
            }

            // Store pin data
            currentPins.push({
                player: currentPlayer,
                x: parseFloat(tempPin.dataset.x),
                y: parseFloat(tempPin.dataset.y)
            });

            // Make pin permanent
            tempPin.id = '';
            tempPin = null;

            // Hide confirm button
            document.getElementById('confirm-btn').classList.remove('visible');

            // Next player or end round
            currentPlayer++;
            if (currentPlayer >= NUM_PLAYERS) {
                endRound();
            } else {
                updateCurrentPlayer();
            }
        }

        function endRound() {
            const level = LEVELS[currentLevel];
            const roundScores = [];

            // Calculate distances and scores using GeoGuessr formula:
            // score = 5000 * e^(-10 * distance / mapSize)
            currentPins.forEach((pin, index) => {
                const distance = calculateDistance(
                    pin.x, pin.y,
                    level.correctX, level.correctY
                );
                // GeoGuessr exponential scoring
                const score = Math.round(MAX_SCORE * Math.exp(-10 * distance / MAP_DIAGONAL));
                scores[pin.player] += score;
                roundScores.push({
                    player: pin.player,
                    distance: distance.toFixed(1),
                    score: score
                });

                // Store for final summary
                allGamePins.push({
                    level: currentLevel,
                    player: pin.player,
                    x: pin.x,
                    y: pin.y,
                    correctX: level.correctX,
                    correctY: level.correctY
                });

                // Add score label to the pin on the map
                addScoreLabelToPin(pin.player, score);
            });

            // Show correct answer on map
            showCorrectAnswer(level.correctX, level.correctY);

            // Update scoreboard
            updateScoreboard();

            // Show round results
            showRoundResults(roundScores);
        }

        function calculateDistance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }

        function showCorrectAnswer(x, y) {
            const mapWrapper = document.getElementById('map-wrapper');

            // Draw lines from each guess to the correct answer
            drawDistanceLines(x, y);

            // Add correct answer pin
            const correctPin = document.createElement('div');
            correctPin.className = 'pin correct';
            correctPin.style.left = `${x}%`;
            correctPin.style.top = `${y}%`;
            mapWrapper.appendChild(correctPin);
        }

        function addScoreLabelToPin(playerIndex, score) {
            const mapWrapper = document.getElementById('map-wrapper');
            const pins = mapWrapper.querySelectorAll('.pin:not(.correct)');

            // Find the pin for this player (they're added in order)
            pins.forEach(pin => {
                if (parseInt(pin.dataset.player) === playerIndex + 1 && !pin.querySelector('.pin-score')) {
                    const label = document.createElement('div');
                    label.className = 'pin-score';
                    label.textContent = `+${score}`;
                    pin.appendChild(label);
                }
            });
        }

        function drawDistanceLines(correctX, correctY) {
            const svg = document.getElementById('lines-svg');
            svg.innerHTML = ''; // Clear any existing lines

            // Draw outline lines first (behind colored lines)
            currentPins.forEach(pin => {
                const outline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                outline.setAttribute('x1', `${pin.x}%`);
                outline.setAttribute('y1', `${pin.y}%`);
                outline.setAttribute('x2', `${correctX}%`);
                outline.setAttribute('y2', `${correctY}%`);
                outline.setAttribute('class', 'distance-line-outline');
                svg.appendChild(outline);
            });

            // Draw colored lines on top
            currentPins.forEach(pin => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', `${pin.x}%`);
                line.setAttribute('y1', `${pin.y}%`);
                line.setAttribute('x2', `${correctX}%`);
                line.setAttribute('y2', `${correctY}%`);
                line.setAttribute('class', 'distance-line');
                line.setAttribute('stroke', PLAYER_COLORS[pin.player]);
                svg.appendChild(line);
            });
        }

        function updateScoreboard() {
            for (let i = 0; i < NUM_PLAYERS; i++) {
                document.getElementById(`score-${i + 1}`).textContent = scores[i];
            }
        }

        function showRoundResults(roundScores) {
            // Sort by score (highest first)
            roundScores.sort((a, b) => b.score - a.score);

            const scoresDiv = document.getElementById('level-scores');
            scoresDiv.innerHTML = roundScores.map(r => `
                <div class="level-result-row">
                    ${playerPhotos[r.player]
                        ? `<img class="player-avatar" src="${playerPhotos[r.player]}" style="border-color: ${PLAYER_COLORS[r.player]}">`
                        : `<span class="player-dot" style="background: ${PLAYER_COLORS[r.player]}; width: 32px; height: 32px; border-radius: 50%; margin-right: 8px;"></span>`
                    }
                    <span class="player-name" style="color: ${PLAYER_COLORS[r.player]}">${PLAYER_NAMES[r.player]}</span>
                    <span class="points">+${r.score}</span>
                </div>
            `).join('');

            // Update button text
            const nextBtn = document.getElementById('next-level-btn');
            if (currentLevel >= LEVELS.length - 1) {
                nextBtn.textContent = 'Показать итоги';
            } else {
                nextBtn.textContent = 'Далее';
            }

            // Show results in sidebar
            document.getElementById('round-results').style.display = 'block';
        }

        function nextLevel() {
            // Hide round results
            document.getElementById('round-results').style.display = 'none';

            if (currentLevel >= LEVELS.length - 1) {
                showFinalResults();
            } else {
                loadLevel(currentLevel + 1);
            }
        }

        function clearPins() {
            const mapWrapper = document.getElementById('map-wrapper');
            const pins = mapWrapper.querySelectorAll('.pin');
            pins.forEach(pin => pin.remove());

            // Clear distance lines
            const svg = document.getElementById('lines-svg');
            svg.innerHTML = '';
        }

        function showFinalResults() {
            document.getElementById('game-screen').style.display = 'none';
            document.getElementById('results-screen').style.display = 'block';

            // Create sorted results
            const results = scores.map((score, index) => ({
                player: index,
                score: score
            })).sort((a, b) => b.score - a.score);

            const finalScoresDiv = document.getElementById('final-scores');
            finalScoresDiv.innerHTML = results.map((r, i) => `
                <div class="final-score-row ${i === 0 ? 'winner' : ''}">
                    <span class="place">${i + 1}.</span>
                    ${playerPhotos[r.player]
                        ? `<img class="player-avatar" src="${playerPhotos[r.player]}" style="border-color: ${PLAYER_COLORS[r.player]}">`
                        : `<span class="player-dot" style="background: ${PLAYER_COLORS[r.player]}; width: 40px; height: 40px; border-radius: 50%; margin-right: 8px;"></span>`
                    }
                    <span style="color: ${PLAYER_COLORS[r.player]}; flex: 1;">${PLAYER_NAMES[r.player]}</span>
                    <span>${r.score}</span>
                </div>
            `).join('');

            // Draw all pins and lines on the final map
            drawFinalMap();
        }

        function drawFinalMap() {
            const wrapper = document.getElementById('final-map-wrapper');
            const svg = document.getElementById('final-lines-svg');
            svg.innerHTML = '';

            // Remove any existing pins/labels
            wrapper.querySelectorAll('.pin, .level-label').forEach(el => el.remove());

            // Group pins by level
            const levelPins = {};
            allGamePins.forEach(pin => {
                if (!levelPins[pin.level]) {
                    levelPins[pin.level] = [];
                }
                levelPins[pin.level].push(pin);
            });

            // Draw for each level
            Object.keys(levelPins).forEach(levelIndex => {
                const pins = levelPins[levelIndex];
                const correctX = pins[0].correctX;
                const correctY = pins[0].correctY;

                // Draw outline lines first
                pins.forEach(pin => {
                    const outline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    outline.setAttribute('x1', `${pin.x}%`);
                    outline.setAttribute('y1', `${pin.y}%`);
                    outline.setAttribute('x2', `${correctX}%`);
                    outline.setAttribute('y2', `${correctY}%`);
                    outline.setAttribute('class', 'distance-line-outline');
                    svg.appendChild(outline);
                });

                // Draw colored lines
                pins.forEach(pin => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', `${pin.x}%`);
                    line.setAttribute('y1', `${pin.y}%`);
                    line.setAttribute('x2', `${correctX}%`);
                    line.setAttribute('y2', `${correctY}%`);
                    line.setAttribute('class', 'distance-line');
                    line.setAttribute('stroke', PLAYER_COLORS[pin.player]);
                    svg.appendChild(line);
                });

                // Draw player pins
                pins.forEach(pin => {
                    const pinEl = document.createElement('div');
                    pinEl.className = 'pin';
                    pinEl.style.left = `${pin.x}%`;
                    pinEl.style.top = `${pin.y}%`;
                    pinEl.style.background = PLAYER_COLORS[pin.player];
                    pinEl.style.borderColor = PLAYER_COLORS[pin.player];
                    pinEl.dataset.player = pin.player + 1;

                    // Add photo if available
                    if (playerPhotos[pin.player]) {
                        const img = document.createElement('img');
                        img.src = playerPhotos[pin.player];
                        pinEl.appendChild(img);
                        pinEl.classList.add('has-photo');
                    }

                    wrapper.appendChild(pinEl);
                });

                // Draw correct answer pin with level label
                const correctPin = document.createElement('div');
                correctPin.className = 'pin correct';
                correctPin.style.left = `${correctX}%`;
                correctPin.style.top = `${correctY}%`;
                wrapper.appendChild(correctPin);

                // Add level label near correct pin
                const label = document.createElement('div');
                label.className = 'level-label';
                label.textContent = `Ур.${parseInt(levelIndex) + 1}`;
                label.style.left = `${correctX}%`;
                label.style.top = `calc(${correctY}% + 25px)`;
                wrapper.appendChild(label);
            });
        }

        function resetGame() {
            currentLevel = 0;
            currentPlayer = 0;
            scores = [0, 0, 0, 0];
            currentPins = [];
            tempPin = null;
            allGamePins = []; // Clear all game history
            playerPhotos = [null, null, null, null]; // Clear photos

            // Reset scoreboard to dots (remove avatars)
            for (let i = 0; i < NUM_PLAYERS; i++) {
                const row = document.getElementById(`score-row-${i}`);
                const avatar = row.querySelector('.player-avatar');
                if (avatar) {
                    const dot = document.createElement('span');
                    dot.className = 'player-dot';
                    dot.style.background = PLAYER_COLORS[i];
                    avatar.replaceWith(dot);
                }
            }

            updateScoreboard();
            resetZoom();

            // Stop webcam
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
            }
            showWebcam(false);

            document.getElementById('results-screen').style.display = 'none';
            document.getElementById('start-screen').style.display = 'flex';
        }

        // ===========================================
        // EVENT LISTENERS
        // ===========================================

        document.addEventListener('DOMContentLoaded', function() {
            const mapContainer = document.getElementById('map-container');

            // Mouse wheel zoom
            mapContainer.addEventListener('wheel', function(e) {
                e.preventDefault();
                const rect = mapContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
                zoomAtPoint(mouseX, mouseY, delta);
            }, { passive: false });

            // Mouse down - start pan or place pin
            mapContainer.addEventListener('mousedown', function(e) {
                if (e.target.closest('#map-controls') || e.target.closest('#confirm-btn')) return;

                const rect = mapContainer.getBoundingClientRect();
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;
                startPanX = panX;
                startPanY = panY;
                isPanning = true;
                mapContainer.classList.add('panning');
            });

            // Mouse move - pan
            document.addEventListener('mousemove', function(e) {
                if (!isPanning) return;

                const rect = mapContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                panX = startPanX + (mouseX - lastMouseX);
                panY = startPanY + (mouseY - lastMouseY);

                constrainPan();
                updateMapTransform();
            });

            // Mouse up - end pan or place pin
            document.addEventListener('mouseup', function(e) {
                if (!isPanning) return;

                const rect = mapContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const moved = Math.abs(mouseX - lastMouseX) > 5 || Math.abs(mouseY - lastMouseY) > 5;

                isPanning = false;
                mapContainer.classList.remove('panning');

                // If didn't move much, treat as click to place pin
                if (!moved && e.target.closest('#map-container') && !e.target.closest('#map-controls') && !e.target.closest('#confirm-btn')) {
                    placePin(mouseX, mouseY);
                }
            });

            // Prevent context menu on map
            mapContainer.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        });
    </script>
</body>
</html>
